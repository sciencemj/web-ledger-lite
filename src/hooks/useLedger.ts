
import { useState, useCallback, useEffect } from 'react';
import type { Transaction, TransactionFormData, MonthlySummaryData, ChartDataPoint, FixedCostItem, SavingsSummaryData } from '@/lib/types';
import { format, parseISO, startOfMonth, endOfMonth, subMonths, getMonth, getYear } from 'date-fns';
import { MONTH_NAMES } from '@/lib/consts';
import { supabase } from '@/lib/supabase';
import { useToast } from './use-toast';

export function useLedger(userId: string | null) {
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const { toast } = useToast();

  const fetchTransactions = useCallback(async (currentUserId: string) => {
    if (!currentUserId) {
      setTransactions([]);
      setIsLoading(false);
      return;
    }
    setIsLoading(true);
    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .eq('user_id', currentUserId)
      .order('date', { ascending: false });

    if (error) {
      console.error('Error fetching transactions:', error);
      toast({ title: "Error", description: "Could not fetch transactions.", variant: "destructive" });
      setTransactions([]);
    } else {
      setTransactions(data as Transaction[] || []);
    }
    setIsLoading(false);
  }, [toast]);

  useEffect(() => {
    if (userId) {
      fetchTransactions(userId);
    } else {
      setTransactions([]);
      setIsLoading(false);
    }
  }, [userId, fetchTransactions]);

  const addTransaction = useCallback(async (
    formData: TransactionFormData,
    isSystemEntry: boolean = false, 
    explicitId?: string 
  ) => {
    if (!userId) {
      toast({ title: "Error", description: "User not authenticated.", variant: "destructive" });
      return;
    }

    let id: string;
    if (explicitId) { // System entries with explicit ID (like auto-savings or fixed cost sync)
        id = explicitId;
    } else {
        id = crypto.randomUUID(); // New manual transactions
    }
    
    const transactionDate = format(formData.date, "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");

    const newTransactionData = {
      // id is generated by DB or passed explicitly
      user_id: userId,
      type: formData.type,
      category: formData.category,
      description: formData.description || 
                   (formData.category === 'automatic_savings_transfer' ? `Auto-savings for ${format(formData.date, 'MMM yyyy')}` : 
                   (formData.category === 'manual_savings' ? `Manual Savings: ${formData.description || format(formData.date, 'MMM dd, yyyy')}`: '')),
      amount: formData.amount,
      date: transactionDate,
      sourceFixedCostId: formData.sourceFixedCostId,
    };

    // For system entries, check if it already exists before inserting
    if (isSystemEntry && explicitId) {
      const { data: existingTransaction, error: fetchError } = await supabase
        .from('transactions')
        .select('id')
        .eq('id', explicitId)
        .eq('user_id', userId)
        .maybeSingle();

      if (fetchError) {
        console.error('Error checking existing system transaction:', fetchError);
        toast({ title: "Error", description: "Could not process system transaction.", variant: "destructive" });
        return;
      }
      if (existingTransaction) {
        // console.log(`System transaction ${explicitId} already exists. Skipping.`);
        return; // Already exists, do nothing
      }
    }
    
    const { data: insertedTransaction, error } = await supabase
      .from('transactions')
      .insert( explicitId ? { ...newTransactionData, id } : newTransactionData ) // only provide id if it's explicit
      .select()
      .single();

    if (error) {
      console.error('Error adding transaction:', error);
      toast({ title: "Error", description: "Could not add transaction: " + error.message, variant: "destructive" });
    } else if (insertedTransaction) {
      setTransactions(prev => [insertedTransaction as Transaction, ...prev].sort((a,b) => parseISO(b.date).getTime() - parseISO(a.date).getTime()));
      if (!isSystemEntry) { // Only toast for manual entries
        // toast({ title: "Success", description: "Transaction added." });
      }
    }
  }, [userId, toast]); 

  const getMonthlySummaryData = useCallback((month: number, year: number): MonthlySummaryData => {
    // This logic remains client-side based on the fetched transactions state
    const targetMonthDate = new Date(year, month - 1, 1); 
    const monthStart = startOfMonth(targetMonthDate);
    const monthEnd = endOfMonth(targetMonthDate);

    let totalIncome = 0;
    let totalExpenses = 0;

    transactions.forEach(t => {
      const transactionDate = parseISO(t.date);
      if (transactionDate >= monthStart && transactionDate <= monthEnd) {
        if (t.type === 'income') {
          totalIncome += t.amount;
        } else if (t.type === 'expense') {
          if (t.category !== 'manual_savings' && t.category !== 'automatic_savings_transfer') {
            totalExpenses += t.amount;
          }
        }
      }
    });
    return { totalIncome, totalExpenses, netBalance: totalIncome - totalExpenses };
  }, [transactions]); 

  const getExpenseChartData = useCallback((numMonths: number = 6): ChartDataPoint[] => {
    // This logic remains client-side
    const data: ChartDataPoint[] = [];
    const today = new Date();

    for (let i = numMonths - 1; i >= 0; i--) {
      const targetDate = subMonths(today, i);
      const monthName = MONTH_NAMES[getMonth(targetDate)];
      const yearNum = getYear(targetDate);
      
      const monthStart = startOfMonth(targetDate);
      const monthEnd = endOfMonth(targetDate);

      let monthlyIncome = 0;
      let monthlyExpenses = 0;

      transactions.forEach(t => {
        const transactionDate = parseISO(t.date);
        if (transactionDate >= monthStart && transactionDate <= monthEnd) {
          if (t.type === 'income') {
            monthlyIncome += t.amount;
          } else {
            if (t.category !== 'manual_savings' && t.category !== 'automatic_savings_transfer') {
                 monthlyExpenses += t.amount;
            }
          }
        }
      });
      data.push({ name: `${monthName} ${yearNum.toString().slice(-2)}`, income: monthlyIncome, expenses: monthlyExpenses });
    }
    return data;
  }, [transactions]); 
  
  const deleteTransaction = useCallback(async (id: string) => {
    if (!userId) {
        toast({ title: "Error", description: "User not authenticated.", variant: "destructive" });
        return;
    }
    const { error } = await supabase
      .from('transactions')
      .delete()
      .match({ id: id, user_id: userId });

    if (error) {
      console.error('Error deleting transaction:', error);
      toast({ title: "Error", description: "Could not delete transaction: " + error.message, variant: "destructive" });
    } else {
      setTransactions(prev => prev.filter(t => t.id !== id));
      toast({ title: "Success", description: "Transaction deleted." });
    }
  }, [userId, toast]); 

  const synchronizeFixedCosts = useCallback((fixedCosts: FixedCostItem[], currentMonth: number, currentYear: number) => {
    if (!userId) return;
    const firstDayOfMonth = new Date(currentYear, currentMonth - 1, 1);
    
    fixedCosts.forEach(fc => {
      const transactionData: TransactionFormData = {
        type: 'expense',
        category: fc.category,
        description: `Fixed: ${fc.description}`,
        amount: fc.amount,
        date: firstDayOfMonth, // Date for the transaction
        sourceFixedCostId: fc.id, // Link to the fixed cost item
      };
      // The explicit ID for fixed cost transaction should be unique per fixed cost item per month
      const explicitTxId = `fixed-${fc.id}-${format(firstDayOfMonth, 'yyyy-MM')}`;
      addTransaction(transactionData, true, explicitTxId); 
    });
  }, [addTransaction, userId]); 

  const processAndTransferAutomaticSavings = useCallback((month: number, year: number) => {
    if (!userId) return;
    const today = new Date();
    const firstDayOfTargetMonth = new Date(year, month - 1, 1);
    const firstDayOfCurrentCalendarMonth = startOfMonth(today);

    // Do not process for current or future months
    if (firstDayOfTargetMonth >= firstDayOfCurrentCalendarMonth) {
      return;
    }

    const monthStart = startOfMonth(firstDayOfTargetMonth);
    const monthEnd = endOfMonth(firstDayOfTargetMonth);
    const savingsTransactionId = `auto-save-${userId}-${year}-${String(month).padStart(2, '0')}`;


    // Check if already processed (client-side check before attempting DB insert)
    const alreadyProcessed = transactions.some(t => t.id === savingsTransactionId && t.category === 'automatic_savings_transfer');
    if (alreadyProcessed) {
      // console.log(`Auto-savings for ${MONTH_NAMES[month-1]} ${year} already processed (client-side).`);
      return;
    }

    let monthIncome = 0;
    let monthExpensesExcludingAutoSave = 0;

    transactions.forEach(t => {
      const transactionDate = parseISO(t.date);
      if (transactionDate >= monthStart && transactionDate <= monthEnd) {
        // Exclude any existing auto-savings for this month if somehow it's there but not ID matched
        if (t.id === savingsTransactionId && t.category === 'automatic_savings_transfer') return; 

        if (t.type === 'income') {
          monthIncome += t.amount;
        } else {
           if (t.category !== 'automatic_savings_transfer' && t.category !== 'manual_savings') {
             monthExpensesExcludingAutoSave += t.amount;
           }
        }
      }
    });
    
    const netSurplus = monthIncome - monthExpensesExcludingAutoSave;

    if (netSurplus > 0) {
      // console.log(`Processing auto-savings for ${MONTH_NAMES[month-1]} ${year}: Surplus ${netSurplus}`);
      addTransaction({
        type: 'expense', 
        category: 'automatic_savings_transfer',
        amount: netSurplus,
        date: monthEnd, 
        description: `Auto-savings: ${MONTH_NAMES[month-1]} ${year} surplus`,
      }, 
      true, 
      savingsTransactionId 
      );
    } else {
      // console.log(`No surplus for auto-savings in ${MONTH_NAMES[month-1]} ${year}. Income: ${monthIncome}, Expenses: ${monthExpensesExcludingAutoSave}`);
    }
  }, [transactions, addTransaction, userId]); 

  const getSavingsSummaryData = useCallback((): SavingsSummaryData => {
    // This logic remains client-side
    let totalSavings = 0;
    let manualContributions = 0;
    let automaticContributions = 0;
    const history: Transaction[] = [];

    transactions.forEach(t => {
      if (t.category === 'manual_savings' && t.type === 'expense') { // manual_savings are expenses that go into savings
        totalSavings += t.amount;
        manualContributions += t.amount;
        history.push(t);
      } else if (t.category === 'automatic_savings_transfer' && t.type === 'expense') { // auto_savings are also expenses that go into savings
        totalSavings += t.amount;
        automaticContributions += t.amount;
        history.push(t);
      }
    });
    history.sort((a, b) => parseISO(b.date).getTime() - parseISO(a.date).getTime());
    return { totalSavings, manualContributions, automaticContributions, history };
  }, [transactions]); 

  return { 
    transactions, 
    addTransaction, 
    getMonthlySummaryData, 
    getExpenseChartData, 
    deleteTransaction, 
    synchronizeFixedCosts,
    processAndTransferAutomaticSavings,
    getSavingsSummaryData,
    isLoading,
  };
}
